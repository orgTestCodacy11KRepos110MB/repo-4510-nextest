<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Derive [`syn::parse::Parse`] for syntax tree node."><meta name="keywords" content="rust, rustlang, rust-lang, Parse"><title>Parse in structmeta - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-6827029ac823cab7.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-ebce58d0a40c3431.css"><link rel="stylesheet" disabled href="../static.files/dark-f23faae4a2daf9a6.css"><link rel="stylesheet" disabled href="../static.files/ayu-8af5e100b21cd173.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-c55e1eb52e1886b4.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc derive"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../structmeta/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../structmeta/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><div class="sidebar-elems"><h2><a href="index.html">In structmeta</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Derive Macro <a href="index.html">structmeta</a>::<wbr><a class="derive" href="#">Parse</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/structmeta_derive/lib.rs.html#22">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust derive"><code>#[derive(Parse)]
{
    // Attributes available to this derive:
    #[to_tokens]
    #[parse]
}
</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Derive <a href="../syn/parse/trait.Parse.html" title="syn::parse::Parse"><code>syn::parse::Parse</code></a> for syntax tree node.</p>
<ul>
<li><a href="#example">Example</a></li>
<li><a href="#helper-attributes">Helper attributes</a>
<ul>
<li><a href="#to_tokens-to_tokens"><code>#[to_tokens(&quot;[&quot;)]</code>, <code>#[to_tokens(&quot;]&quot;)]</code></a></li>
<li><a href="#to_tokens-to_tokens-1"><code>#[to_tokens(&quot;(&quot;)]</code>, <code>#[to_tokens(&quot;)&quot;)]</code></a></li>
<li><a href="#to_tokens-to_tokens-2"><code>#[to_tokens(&quot;{&quot;)]</code>, <code>#[to_tokens(&quot;}&quot;)]</code></a></li>
<li><a href="#parsepeek"><code>#[parse(peek)]</code></a></li>
<li><a href="#parseany"><code>#[parse(any)]</code></a></li>
<li><a href="#parseterminated"><code>#[parse(terminated)]</code></a></li>
<li><a href="#parsedump"><code>#[parse(dump)]</code></a></li>
</ul>
</li>
</ul>
<h2 id="example"><a href="#example">Example</a></h2>
<p><code>#[derive(Parse)]</code> generates an implementation of <code>Parse</code> that calls <a href="../syn/parse/trait.Parse.html#tymethod.parse"><code>Parse::parse</code></a> for each field.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>syn::{LitInt, LitStr};

<span class="attr">#[derive(structmeta::Parse)]
</span><span class="kw">struct </span>Example(LitInt, LitStr);</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>syn::parse::Parse <span class="kw">for </span>Example {
    <span class="kw">fn </span>parse(input: syn::parse::ParseStream) -&gt; syn::Result&lt;<span class="self">Self</span>&gt; {
        <span class="kw">let </span>_0 = input.parse()<span class="question-mark">?</span>;
        <span class="kw">let </span>_1 = input.parse()<span class="question-mark">?</span>;
        <span class="kw">return </span><span class="prelude-val">Ok</span>(Example(_0, _1));
    }
}</code></pre></div>
<p><code>#[derive(Parse)]</code> can also be specified for enum.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>syn::{LitInt, LitStr};

<span class="attr">#[derive(structmeta::Parse)]
</span><span class="kw">enum </span>Example {
    A(LitInt, LitInt),
    B(LitStr),
}</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>syn::parse::discouraged::Speculative;
<span class="kw">impl </span>syn::parse::Parse <span class="kw">for </span>Example {
    <span class="kw">fn </span>parse(input: syn::parse::ParseStream) -&gt; syn::Result&lt;<span class="self">Self</span>&gt; {
        <span class="kw">let </span>fork = input.fork();
        <span class="kw">if let </span><span class="prelude-val">Ok</span>(value) = fork.call(|input| <span class="prelude-val">Ok</span>(Example::A(input.parse()<span class="question-mark">?</span>, input.parse()<span class="question-mark">?</span>))) {
            input.advance_to(<span class="kw-2">&amp;</span>fork);
            <span class="kw">return </span><span class="prelude-val">Ok</span>(value);
        }

        <span class="kw">let </span>fork = input.fork();
        <span class="kw">if let </span><span class="prelude-val">Ok</span>(value) = fork.call(|input| <span class="prelude-val">Ok</span>(Example::B(input.parse()<span class="question-mark">?</span>))) {
            input.advance_to(<span class="kw-2">&amp;</span>fork);
            <span class="kw">return </span><span class="prelude-val">Ok</span>(value);
        }

        <span class="prelude-val">Err</span>(input.error(<span class="string">&quot;parse failed.&quot;</span>))
    }
}</code></pre></div>
<h2 id="helper-attributes"><a href="#helper-attributes">Helper attributes</a></h2><div><table><thead><tr><th></th><th>struct</th><th>enum</th><th>varaint</th><th>field</th></tr></thead><tbody>
<tr><td><a href="#to_tokens-to_tokens"><code>#[to_tokens(&quot;[&quot;)]</code>, <code>#[to_tokens(&quot;]&quot;)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#to_tokens-to_tokens-1"><code>#[to_tokens(&quot;(&quot;)]</code>, <code>#[to_tokens(&quot;)&quot;)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#to_tokens-to_tokens-2"><code>#[to_tokens(&quot;{&quot;)]</code>, <code>#[to_tokens(&quot;}&quot;)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#parsepeek"><code>#[parse(peek)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#parseany"><code>#[parse(any)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#parseterminated"><code>#[parse(terminated)]</code></a></td><td></td><td></td><td></td><td>✔</td></tr>
<tr><td><a href="#parsedump"><code>#[parse(dump)]</code></a></td><td>✔</td><td>✔</td><td></td><td></td></tr>
</tbody></table>
</div><h3 id="to_tokens-to_tokens"><a href="#to_tokens-to_tokens"><code>#[to_tokens(&quot;[&quot;)]</code>, <code>#[to_tokens(&quot;]&quot;)]</code></a></h3>
<p>By specifying <code>#[to_tokens(&quot;[&quot;)]</code> for a field of type <a href="../syn/token/struct.Bracket.html" title="syn::token::Bracket"><code>syn::token::Bracket</code></a>, subsequent tokens will be enclosed in <code>[]</code>.</p>
<p>By default, all subsequent fields are enclosed.
To restrict the enclosing fields, specify <code>#[to_tokens(&quot;]&quot;)]</code> for the field after the end of the enclosure.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>syn::{token, LitInt};

<span class="attr">#[derive(structmeta::Parse)]
</span><span class="kw">struct </span>Example {
    x: LitInt,
    <span class="attr">#[to_tokens(<span class="string">&quot;[&quot;</span>)]
    </span>bracket_token: token::Bracket,
    y: LitInt,
    <span class="attr">#[to_tokens(<span class="string">&quot;]&quot;</span>)]
    </span>z: LitInt,
}</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>syn::parse::Parse <span class="kw">for </span>Example {
    <span class="kw">fn </span>parse(input: syn::parse::ParseStream) -&gt; syn::Result&lt;<span class="self">Self</span>&gt; {
        <span class="kw">let </span>x = input.parse()<span class="question-mark">?</span>;
        <span class="kw">let </span>content;
        <span class="kw">let </span>bracket_token = <span class="macro">syn::bracketed!</span>(content <span class="kw">in </span>input);
        <span class="kw">let </span>y = content.parse()<span class="question-mark">?</span>;
        <span class="kw">let </span>z = input.parse()<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(<span class="self">Self </span>{
            x,
            bracket_token,
            y,
            z,
        })
    }
}</code></pre></div>
<h3 id="to_tokens-to_tokens-1"><a href="#to_tokens-to_tokens-1"><code>#[to_tokens(&quot;(&quot;)]</code>, <code>#[to_tokens(&quot;)&quot;)]</code></a></h3>
<p>By specifying <code>#[to_tokens(&quot;(&quot;)]</code> for a field of type <a href="../syn/token/struct.Paren.html" title="syn::token::Paren"><code>syn::token::Paren</code></a>, subsequent tokens will be enclosed in <code>()</code>.</p>
<p>By default, all subsequent fields are enclosed.
To restrict the enclosing fields, specify <code>#[to_tokens(&quot;)&quot;)]</code> for the field after the end of the enclosure.</p>
<h3 id="to_tokens-to_tokens-2"><a href="#to_tokens-to_tokens-2"><code>#[to_tokens(&quot;{&quot;)]</code>, <code>#[to_tokens(&quot;}&quot;)]</code></a></h3>
<p>By specifying <code>#[to_tokens(&quot;{&quot;)]</code> for a field of type <a href="../syn/token/struct.Brace.html" title="syn::token::Brace"><code>syn::token::Brace</code></a>, subsequent tokens will be enclosed in <code>{}</code>.</p>
<p>By default, all subsequent fields are enclosed.
To restrict the enclosing fields, specify <code>#[to_tokens(&quot;}&quot;)]</code> for the field after the end of the enclosure.</p>
<h3 id="parsepeek"><a href="#parsepeek"><code>#[parse(peek)]</code></a></h3>
<p>When parsing an enum, it will peek the field with this attribute set,
and if successful, will parse the variant containing the field.
If the peek succeeds, the subsequent variant will not be parsed even if the parse failed.</p>
<p>Variant where <code>#[parse(peek)]</code> is not specified will fork input and parse.</p>
<p>If the peek fails or the parsing of the forked input fails, the subsequent variant will be parsed.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>syn::{LitInt, LitStr};
<span class="attr">#[derive(structmeta::Parse)]
</span><span class="kw">enum </span>Example {
    A(<span class="attr">#[parse(peek)] </span>LitInt, LitInt),
    B(LitStr),
}</code></pre></div>
<p>Code like this will be generated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">impl </span>syn::parse::Parse <span class="kw">for </span>Example {
    <span class="kw">fn </span>parse(input: syn::parse::ParseStream) -&gt; syn::Result&lt;<span class="self">Self</span>&gt; {
        <span class="kw">if </span>input.peek(LitInt) {
            <span class="kw">let </span>a_0 = input.parse()<span class="question-mark">?</span>;
            <span class="kw">let </span>a_1 = input.parse()<span class="question-mark">?</span>;
            <span class="kw">return </span><span class="prelude-val">Ok</span>(Example::A(a_0, a_1));
        }
        <span class="kw">let </span>b_0 = input.parse()<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(Example::B(b_0))
    }
}</code></pre></div>
<p><code>#[parse(peek)]</code> can be specified on the first three <code>TokenTree</code> for each variant.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>syn::{LitInt, LitStr};
<span class="attr">#[derive(structmeta::Parse)]
</span><span class="kw">enum </span>Example {
    A(<span class="attr">#[parse(peek)] </span>LitInt, <span class="attr">#[parse(peek)]</span>LitInt, <span class="attr">#[parse(peek)]</span>LitInt),
    B(<span class="attr">#[parse(peek)] </span>LitStr),
}</code></pre></div>
<p>Since the tokens enclosed by the delimiter is treated as a single token tree, you can also specify <code>#[parse(peek)]</code> to the field with <code>#[to_tokens(&quot;]&quot;)]</code>, <code>#[to_tokens(&quot;}&quot;)]</code>, <code>#[to_tokens(&quot;)&quot;)]</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>syn::{token, LitInt, LitStr};
<span class="attr">#[derive(structmeta::Parse)]
</span><span class="kw">enum </span>Example {
    A {
        <span class="attr">#[parse(peek)]
        #[to_tokens(<span class="string">&quot;{&quot;</span>)]
        </span>a: token::Brace,
        b: LitInt,
        c: LitInt,
        <span class="attr">#[to_tokens(<span class="string">&quot;}&quot;</span>)]
        #[parse(peek)]
        </span>d: LitInt,
    },
}</code></pre></div>
<p>To use <code>#[parse(peek)]</code> for a field that type is <code>Ident</code>, use <code>syn::Ident</code> insted of <code>proc_macro2::Ident</code>.</p>

<div class="example-wrap compile_fail"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(structmeta::Parse)]
</span><span class="kw">enum </span>ExampleNg {
    A(<span class="attr">#[parse(peek)] </span>proc_macro2::Ident),
}</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(structmeta::Parse)]
</span><span class="kw">enum </span>ExampleOk {
    A(<span class="attr">#[parse(peek)] </span>syn::Ident),
}</code></pre></div>
<h3 id="parseany"><a href="#parseany"><code>#[parse(any)]</code></a></h3>
<p>When parsing <code>Ident</code>, allow values that cannot be used as identifiers, such as keywords.</p>
<p>In other words, <code>Ident::parse_any</code> and <code>Ident::peek_any</code> was generated instead of <code>Ident::parse</code> and <code>Ident::peek</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quote::quote;
<span class="kw">use </span>structmeta::Parse;
<span class="kw">use </span>syn::{parse2, Ident};

<span class="attr">#[derive(Parse)]
</span><span class="kw">struct </span>WithAny(<span class="attr">#[parse(any)] </span>Ident);

<span class="attr">#[derive(Parse)]
</span><span class="kw">struct </span>WithoutAny(Ident);

<span class="macro">assert_eq!</span>(parse2::&lt;WithAny&gt;(<span class="macro">quote!</span>(<span class="self">self</span>)).is_ok(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(parse2::&lt;WithoutAny&gt;(<span class="macro">quote!</span>(<span class="self">self</span>)).is_ok(), <span class="bool-val">false</span>);</code></pre></div>
<h3 id="parseterminated"><a href="#parseterminated"><code>#[parse(terminated)]</code></a></h3>
<p>Use <a href="../syn/punctuated/struct.Punctuated.html#method.parse_terminated"><code>Punctuated::parse_terminated</code></a> to parse.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quote::quote;
<span class="kw">use </span>structmeta::Parse;
<span class="kw">use </span>syn::{parse2, punctuated::Punctuated, Ident, Token};
<span class="attr">#[derive(Parse)]
</span><span class="kw">struct </span>Example(<span class="attr">#[parse(terminated)] </span>Punctuated&lt;Ident, <span class="macro">Token!</span>[,]&gt;);
<span class="macro">assert_eq!</span>(parse2::&lt;Example&gt;(<span class="macro">quote!</span>(a, b, c)).is_ok(), <span class="bool-val">true</span>);</code></pre></div>
<p><code>terminated</code> can also be used with <code>any</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>quote::quote;
<span class="kw">use </span>structmeta::Parse;
<span class="kw">use </span>syn::{parse2, punctuated::Punctuated, Ident, Token};

<span class="attr">#[derive(Parse)]
</span><span class="kw">struct </span>WithAny(<span class="attr">#[parse(terminated, any)] </span>Punctuated&lt;Ident, <span class="macro">Token!</span>[,]&gt;);

<span class="attr">#[derive(Parse)]
</span><span class="kw">struct </span>WithoutAny(<span class="attr">#[parse(terminated)] </span>Punctuated&lt;Ident, <span class="macro">Token!</span>[,]&gt;);

<span class="macro">assert_eq!</span>(parse2::&lt;WithAny&gt;(<span class="macro">quote!</span>(<span class="self">self</span>, <span class="self">self</span>)).is_ok(), <span class="bool-val">true</span>);
<span class="macro">assert_eq!</span>(parse2::&lt;WithoutAny&gt;(<span class="macro">quote!</span>(<span class="self">self</span>, <span class="self">self</span>)).is_ok(), <span class="bool-val">false</span>);</code></pre></div>
<h3 id="parsedump"><a href="#parsedump"><code>#[parse(dump)]</code></a></h3>
<p>Causes a compile error and outputs the code generated by <code>#[derive(Parse)]</code> as an error message.</p>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="structmeta" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0 (fc594f156 2023-01-24)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>